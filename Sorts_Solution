#include <bits/stdc++.h>
using namespace std;
/*** 排序基础函数 ***/
class My_Sort {
public :
    virtual void Sorts(vector<int>& arr) = 0;
};
/******/
/*** 堆排序的迭代实现 : ***/
class My_Sort_Heap : public My_Sort {
public :
    /***
    堆排序 : 时间复杂度 O(n * log(n)), 空间复杂度: O(1) (迭代实现)
    将整个数组看作一个完全二叉树，通过不断维护将整个数组保证成为一个大根堆，每次将
    完全二叉树结尾节点和根节点互换位置，然后剪去末尾节点加入数组尾部，来实现排序。
    ***/
    virtual void Sorts(vector<int>& arr) {
        if (arr.empty()) return ; //非法输入检测
        int n = arr.size();
        Build_Heap(arr, n); //先维护住整体heap性质
        for (int i = n - 1; i >= 0; -- i) {
            swap(arr[0], arr[i]); //根和尾交换值
            Sink(arr, 0, i); // 从根开始修改，但注意，整个完全二叉树大小改变了。
        }
    };
private:
    /** Sink操作主要用于维护heap性质，确保子节点值小于当前节点值 **/
    void Sink(vector<int> &arr, int idx, int n) {
        while (idx * 2 + 1 < n) { //最多置换到完全二叉树的底部
            int mxx = idx;
            int left = idx * 2 + 1; // 检查左儿子
            if (left < n and arr[left] > arr[mxx]) {
                mxx = left;
            }
            int right = idx * 2 + 2; // 检查右儿子
            if (right < n and arr[right] > arr[mxx]) {
                mxx = right;
            }
            if (mxx == idx) break; // 如果当前符合heap性质
            swap(arr[idx], arr[mxx]); //交换值
            idx = mxx; //检查下一个节点
        }
    }
    /** Build_Heap 主要用于从完全二叉子树最后一个节点的父节点开始依次由底向上维护整棵树heap性质 **/
    void Build_Heap(vector<int>& arr, int sizes) {
        int lst_node = sizes - 1; // 完全二叉树最后一个节点
        int lst_pre = (lst_node - 1) / 2; //最后一个节点的父亲
        for (int i = lst_pre; i >= 0; -- i) {
            Sink(arr, i, sizes); // build heap from bottom to top
        }
    }
};

/*** 快速排序的迭代实现 : ***/
class My_Sort_Quick: public My_Sort {
    /*** 
    快速排序： 时间复杂度 最好，平均都是 O(n * log(n)) 有说法最好是 O(n), 最坏 O(n ^ 2)
              不稳定排序， 空间复杂度O(n * log(n)可以迭代实现
    思想就是选择一个适当的数字，将它作为区间”枢纽”， 小于他的放在左侧，大于的放在右侧，以此
    实现排序。
    
    ***/
public :
    virtual void Sorts(vector<int>& arr) {
        if (arr.empty()) return ; // 非法输入检测
        stack<int> data; //迭代辅助栈
        int n = arr.size();
        data.push(n - 1); //记得先塞入 r 再塞入 l,（栈的性质）
        data.push(0);
        while (!data.empty()) {
            int l = data.top(); data.pop();
            int r = data.top(); data.pop();
            int p = Partition(arr, l, r); //寻找枢纽点
            if (p - 1 > l) { // 检测左侧区间是否需要排序
                data.push(p - 1);
                data.push(l);
            }
            if (p + 1 < r) { // 检测右侧区间是否需要排序
                data.push(r);
                data.push(p + 1);
            }
        }
    };
private:
    int Partition(vector<int> &arr, int l, int r) {
        int mid = l + ((r - l) >> 1); // 此处最好是随机一个数字，当然为了方便，取了中点。
        swap(arr[r], arr[mid]);
        int t = l; //t表示最终划分元素应该在的位置
        for (int i = l; i < r; ++ i) { //从从左到右扫描
            if (arr[i] < arr[r]) {  //找打比划分元素小的
                swap(arr[t ++], arr[i]); // t要么等于i，交互自身，要么比i位置的元素大
            }
        }
        swap(arr[t], arr[r]); //记得把枢纽点放到适合的位置
        return t; //返回枢纽点位置
    }
};

void Test_fuc() {
    int n; scanf("%d", &n);
    vector<int> arr(n);
    for (int i = 0; i < n; ++ i) {
        scanf("%d", &arr[i]);
    }
    /*** make your own choices ***/
    // My_Sort* solution = new My_Sort_Heap;
    // My_Sort* solution = new My_Sort_Quick;
    solution->Sorts(arr);
    delete solution;
    for (int i = 0; i < n; ++ i) {
        printf("%d%c", arr[i], i == n - 1 ? '\n' : ' ');
    }
}
signed main() {
    Test_fuc();
    return 0;
}
